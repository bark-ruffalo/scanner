import "server-only";
import { eq, and } from "drizzle-orm";
import { revalidatePath } from "next/cache";
import { db } from "./db";
import { launches } from "./db/schema";

// Define the type for data needed to create a new launch record.
// It uses TypeScript's Omit utility type to take the 'launches' table insert type
// (inferred by Drizzle as `typeof launches.$inferInsert`) and exclude properties
// that are automatically generated by the database (id, createdAt, updatedAt).
// This ensures that functions adding launches only accept the required fields.
type NewLaunchData = Omit<
	typeof launches.$inferInsert,
	"id" | "createdAt" | "updatedAt"
>;

/**
 * Fetches launch records from the database.
 * Optionally filters launches by launchpad name.
 * @param filter Optional string. If provided and not "All", filters by `launches.launchpad`.
 * @returns A promise that resolves to an array of launch objects.
 */
export async function getLaunches(filter?: string) {
	console.log(
		`Fetching launches from DB. Filter: ${filter ?? "None (fetching all)"}`,
	);
	// Uses Drizzle's query builder (`db.query.launches`).
	const result = await db.query.launches.findMany({
		// Conditional 'where' clause:
		// - If a filter exists and is not the string "All", it adds a condition
		//   where the `launchpad` column must equal the filter value (`eq(launches.launchpad, filter)`).
		// - Otherwise (no filter or filter is "All"), the `where` clause is undefined, fetching all records.
		where:
			filter && filter !== "All" ? eq(launches.launchpad, filter) : undefined,
		// Orders the results by the `createdAt` column in descending order (newest first).
		orderBy: (launches, { desc }) => [desc(launches.createdAt)],
	});
	console.log(`Fetched ${result.length} launches.`);
	return result;
}

/**
 * Fetches a distinct list of all launchpad names present in the database.
 * Useful for populating filter dropdowns or lists.
 * @returns A promise that resolves to an array of unique launchpad name strings.
 */
export async function getDistinctLaunchpads() {
	console.log("Fetching distinct launchpads from DB...");
	// Uses Drizzle's `selectDistinct` to get unique values from the `launchpad` column.
	const distinctLaunchpadsResult = await db
		.selectDistinct({ launchpad: launches.launchpad })
		.from(launches); // Specifies the table to query from.

	// The result is an array of objects like [{ launchpad: 'Name1' }, { launchpad: 'Name2' }].
	// We map this to extract just the names into a simple string array.
	const launchpadNames = distinctLaunchpadsResult.map(
		({ launchpad }) => launchpad,
	);
	console.log(`Found ${launchpadNames.length} distinct launchpads.`);
	return launchpadNames;
}

/**
 * Inserts a new launch record into the database if it doesn't already exist (based on title and launchpad).
 * After successful insertion, it triggers a revalidation of the Next.js cache
 * for the homepage ('/') to ensure the UI reflects the new data.
 * @param launchData An object conforming to the NewLaunchData type.
 */
export async function addLaunch(launchData: NewLaunchData) {
	console.log(
		`Attempting to add/check launch in DB: ${launchData.title} from ${launchData.launchpad}`,
	);
	try {
		// Check if a launch with the same title and launchpad already exists
		const existingLaunch = await db.query.launches.findFirst({
			where: and(
				eq(launches.title, launchData.title),
				eq(launches.launchpad, launchData.launchpad),
			),
			columns: {
				// Only need to select one column to check for existence
				id: true,
			},
		});

		if (existingLaunch) {
			// If launch exists, log it and do nothing further
			console.log(
				`Duplicate launch detected: "${launchData.title}" from ${launchData.launchpad}. Skipping insertion.`,
			);
			return; // Exit the function early
		}

		// If launch does not exist, proceed with insertion
		console.log(
			`"${launchData.title}" not found. Proceeding with insertion...`,
		);
		await db.insert(launches).values(launchData);
		console.log(
			`Successfully added launch: ${launchData.title} from ${launchData.launchpad}`,
		);

		// Revalidate the cache for the specified path.
		console.log("Revalidating Next.js cache for path: /");
		revalidatePath("/");
		console.log("Cache revalidation triggered for /.");
	} catch (error) {
		// Log any errors that occur during the database check or insertion process.
		console.error(
			`Error processing launch "${launchData.title}" in database:`, // Updated error message context
			error,
		);
		// Depending on application requirements, you might:
		// - Throw the error to be handled by a higher-level error handler.
		// - Implement specific error handling (e.g., for unique constraint violations).
		// - Send the error to an external monitoring service.
		// throw error; // Uncomment to propagate the error
	}
}
