import { and, eq, gt, gte, ne } from "drizzle-orm";
import { revalidatePath } from "next/cache";
import "server-only";
import { env } from "~/env";
import { db } from "./db";
import { launches } from "./db/schema";
import { analyzeLaunch } from "./lib/ai-utils";
import {
	formatLaunchNotification,
	sendTelegramMessage,
} from "./lib/telegram-utils";

// Define the type for data needed to create a new launch record.
// It uses TypeScript's Omit utility type to take the 'launches' table insert type
// (inferred by Drizzle as `typeof launches.$inferInsert`) and exclude properties
// that are automatically generated by the database (id, createdAt, updatedAt).
// This ensures that functions adding launches only accept the required fields.
export type NewLaunchData = Omit<
	typeof launches.$inferInsert,
	"id" | "createdAt" // Keep updatedAt potentially for update logic
>;

/**
 * Fetches launch records from the database.
 * Optionally filters launches by launchpad name and minimum rating.
 * @param filter Optional string. If provided and not "All", filters by `launches.launchpad`.
 * @param minRating Optional string. If provided, filters launches by minimum rating.
 * @returns A promise that resolves to an array of launch objects.
 */
export async function getLaunches(filter?: string, minRating?: string) {
	console.log(
		`Fetching launches from DB. Filter: ${filter ?? "None (fetching all)"}, Min Rating: ${minRating ?? "None"}`,
	);

	const conditions = [];

	// Add launchpad filter condition if provided
	if (filter && filter !== "All") {
		conditions.push(eq(launches.launchpad, filter));
	}

	// Add minimum rating condition if provided
	if (minRating !== undefined) {
		const rating = Number.parseInt(minRating, 10);
		if (!Number.isNaN(rating)) {
			// When minRating is 0, include both unrated (-1) and 0 rated launches
			if (rating === 0) {
				conditions.push(
					gte(launches.rating, -1), // This includes both -1 and 0 ratings
				);
			} else {
				conditions.push(
					and(
						gt(launches.rating, rating - 1), // Using gt with rating-1 is equivalent to gte with rating
						ne(launches.rating, -1),
					),
				);
			}
		}
	}

	// Uses Drizzle's query builder (`db.query.launches`).
	const result = await db.query.launches.findMany({
		where: conditions.length > 0 ? and(...conditions) : undefined,
		columns: {
			id: true,
			title: true,
			launchpad: true,
			rating: true,
			updatedAt: true,
			description: true,
			tokenAddress: true,
			creatorAddress: true,
			creatorInitialTokensHeld: true,
		},
		// Orders the results by the `launchedAt` column in descending order (newest first).
		orderBy: (launches, { desc }) => [desc(launches.launchedAt)],
	});
	console.log(`Fetched ${result.length} launches.`);
	return result;
}

/**
 * Fetches a distinct list of all launchpad names present in the database.
 * Useful for populating filter dropdowns or lists.
 * @returns A promise that resolves to an array of unique launchpad name strings.
 */
export async function getDistinctLaunchpads() {
	console.log("Fetching distinct launchpads from DB...");
	// Uses Drizzle's `selectDistinct` to get unique values from the `launchpad` column.
	const distinctLaunchpadsResult = await db
		.selectDistinct({ launchpad: launches.launchpad })
		.from(launches); // Specifies the table to query from.

	// The result is an array of objects like [{ launchpad: 'Name1' }, { launchpad: 'Name2' }].
	// We map this to extract just the names into a simple string array.
	const launchpadNames = distinctLaunchpadsResult.map(
		({ launchpad }) => launchpad,
	);
	console.log(`Found ${launchpadNames.length} distinct launchpads.`);
	return launchpadNames;
}

/**
 * Inserts a new launch record into the database or updates it if it already exists
 * Before insertion, it uses LLM to analyze, rate and summarize the launch.
 * After successful insertion or update, it triggers a revalidation of the Next.js cache
 * for the homepage ('/') to ensure the UI reflects the new data.
 * @param launchData An object conforming to the NewLaunchData type, which includes:
 *   - Required fields: launchpad, title, url, description
 *   - Optional fields: imageUrl, creatorTokenHoldingPercentage, creatorTokensHeld (string), totalTokenSupply (string)
 */
export async function addLaunch(launchData: NewLaunchData) {
	if (!launchData.launchpadSpecificId) {
		throw new Error(
			"addLaunch: launchpadSpecificId is required for all launches. Refusing to insert launch without unique identifier.",
		);
	}
	console.log(
		`Attempting to add/update launch in DB: launchpadSpecificId=${launchData.launchpadSpecificId} title=${launchData.title} from ${launchData.launchpad}`,
	);
	let actionTaken: "inserted" | "updated" | "skipped" | "error" = "error"; // Track outcome

	try {
		// Check if a launch with the same launchpadSpecificId already exists
		const existingLaunch = await db.query.launches.findFirst({
			where: eq(launches.launchpadSpecificId, launchData.launchpadSpecificId),
			columns: {
				id: true,
				analysis: true,
				summary: true,
				rating: true,
				creatorTokenHoldingPercentage: true,
				creatorTokensHeld: true,
				totalTokenSupply: true,
				creatorInitialTokensHeld: true,
				tokensForSale: true,
				creatorAddress: true,
				tokenAddress: true,
			},
		});

		// Always reanalyze with LLM
		let enhancedData = { ...launchData };
		try {
			console.log("Analyzing launch description with AI...");
			const analysisResult = await analyzeLaunch(
				launchData.description,
				launchData.launchpad,
			);
			console.log(`Analysis complete! Rating: ${analysisResult.rating}/10`);

			// Enhance the data with AI-generated content
			enhancedData = {
				...launchData,
				analysis: analysisResult.analysis,
				summary: analysisResult.summary,
				rating: analysisResult.rating,
				llmAnalysisUpdatedAt: new Date(), // Set LLM analysis timestamp
			};
		} catch (analysisError) {
			console.error("Error during AI analysis:", analysisError);
			// Continue with original data if analysis fails
			console.log("Proceeding with original data (without AI analysis).");
		}

		if (existingLaunch) {
			console.log(
				`Duplicate launch detected: launchpadSpecificId=${launchData.launchpadSpecificId}. Overwriting...`,
			);
			// Prepare data for update, preserving existing token data if not provided in update
			const updateData: Partial<typeof launches.$inferInsert> = {
				...enhancedData,
				creatorTokenHoldingPercentage:
					enhancedData.creatorTokenHoldingPercentage ??
					existingLaunch.creatorTokenHoldingPercentage,
				creatorTokensHeld:
					enhancedData.creatorTokensHeld ?? existingLaunch.creatorTokensHeld,
				totalTokenSupply:
					enhancedData.totalTokenSupply ?? existingLaunch.totalTokenSupply,
				creatorInitialTokensHeld:
					enhancedData.creatorInitialTokensHeld ??
					existingLaunch.creatorInitialTokensHeld,
				tokensForSale:
					enhancedData.tokensForSale ?? existingLaunch.tokensForSale,
				basicInfoUpdatedAt: new Date(),
				creatorAddress:
					enhancedData.creatorAddress ?? existingLaunch.creatorAddress,
				tokenAddress: enhancedData.tokenAddress ?? existingLaunch.tokenAddress,
			};

			const [updatedLaunch] = await db
				.update(launches)
				.set(updateData)
				.where(eq(launches.id, existingLaunch.id))
				.returning();

			if (updatedLaunch) {
				const hasSignificantChanges =
					enhancedData.creatorTokenMovementDetails ||
					enhancedData.creatorTokenHoldingPercentage !==
						existingLaunch.creatorTokenHoldingPercentage;

				if (hasSignificantChanges) {
					try {
						const message = formatLaunchNotification(
							updatedLaunch.title,
							updatedLaunch.url,
							updatedLaunch.summary,
							updatedLaunch.analysis,
							updatedLaunch.rating,
							updatedLaunch.id,
							updatedLaunch.launchpad,
						);
						await sendTelegramMessage(
							message,
							env.TELEGRAM_GROUP_ID,
							env.TELEGRAM_TOPIC_ID,
						);
					} catch (error) {
						console.error("Failed to send Telegram notification:", error);
					}
				}
			}

			console.log(
				`Successfully updated launch: launchpadSpecificId=${launchData.launchpadSpecificId}`,
			);
			actionTaken = "updated";
		} else {
			console.log(
				`launchpadSpecificId=${launchData.launchpadSpecificId} not found. Proceeding with insertion...`,
			);
			const [insertedLaunch] = await db
				.insert(launches)
				.values({
					...enhancedData,
					basicInfoUpdatedAt: new Date(),
					llmAnalysisUpdatedAt: new Date(),
				})
				.returning();

			if (insertedLaunch) {
				try {
					const message = formatLaunchNotification(
						insertedLaunch.title,
						insertedLaunch.url,
						insertedLaunch.summary,
						insertedLaunch.analysis,
						insertedLaunch.rating,
						insertedLaunch.id,
						insertedLaunch.launchpad,
					);
					await sendTelegramMessage(
						message,
						env.TELEGRAM_GROUP_ID,
						env.TELEGRAM_TOPIC_ID,
					);
				} catch (error) {
					console.error("Failed to send Telegram notification:", error);
				}
				console.log(
					`Successfully added launch: launchpadSpecificId=${launchData.launchpadSpecificId}`,
				);
				actionTaken = "inserted";
			}
		}

		try {
			// Check if the server is running before attempting to revalidate
			try {
				const response = await fetch("http://localhost:3000");
				if (!response.ok) {
					console.warn("Homepage revalidation skipped: Server is not running.");
				}
			} catch (serverError) {
				console.warn("Homepage revalidation skipped: Server is not running.");
			}

			await fetch("http://localhost:3000/api/revalidate-homepage", {
				method: "POST",
			});
		} catch (e) {
			console.error(
				"Failed to trigger homepage revalidation via API route:",
				e,
			);
		}
		return actionTaken;
	} catch (error) {
		actionTaken = "error";
		console.error(
			`Error processing launch launchpadSpecificId=${launchData.launchpadSpecificId} in database:`,
			error,
		);
		return actionTaken;
	}
}

export async function getLaunchById(id: number) {
	// Ensure db connection is established if not already
	const launch = await db.query.launches.findFirst({
		where: eq(launches.id, id),
	});
	return launch ?? null; // Return the launch or null if not found
}

export async function getLaunchMetadata(id: number) {
	const launch = await getLaunchById(id);
	return {
		title: launch ? `${launch.title} | Scanner` : "Launch Not Found | Scanner",
	};
}

export interface TokenUpdateResult {
	creatorTokensHeld: string;
	creatorTokenHoldingPercentage: string | null;
	tokenStatsUpdatedAt: Date;
	creatorTokenMovementDetails?: string;
	mainSellingAddress?: string;
	sentToZeroAddress?: boolean;
}

/**
 * Updates token statistics in the database for a specific launch.
 *
 * @param launchId - The ID of the launch to update
 * @param tokenStats - The token statistics to update
 */
export async function updateTokenStatisticsInDb(
	launchId: number,
	tokenStats: TokenUpdateResult,
) {
	await db
		.update(launches)
		.set({
			// Ensure these are treated as strings for the numeric type
			creatorTokensHeld: tokenStats.creatorTokensHeld,
			creatorTokenHoldingPercentage: tokenStats.creatorTokenHoldingPercentage,
			creatorTokenMovementDetails: tokenStats.creatorTokenMovementDetails,
			tokenStatsUpdatedAt: tokenStats.tokenStatsUpdatedAt,
			sentToZeroAddress: tokenStats.sentToZeroAddress ?? false,
			updatedAt: new Date(),
		})
		.where(eq(launches.id, launchId));
}

/**
 * Updates a launch's description and analysis data
 * @param launchId The ID of the launch to update
 * @param data The updated launch data
 */
export async function updateLaunchAnalysis(
	launchId: number,
	data: {
		description: string;
		analysis: string;
		summary: string;
		rating: number;
		llmAnalysisUpdatedAt: Date;
	},
) {
	await db.update(launches).set(data).where(eq(launches.id, launchId));
}
