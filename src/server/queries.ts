import "server-only";
import { eq } from "drizzle-orm";
import { revalidatePath } from "next/cache";
import { db } from "./db";
import { launches } from "./db/schema";

// Define the type for data needed to create a new launch record.
// It uses TypeScript's Omit utility type to take the 'launches' table insert type
// (inferred by Drizzle as `typeof launches.$inferInsert`) and exclude properties
// that are automatically generated by the database (id, createdAt, updatedAt).
// This ensures that functions adding launches only accept the required fields.
type NewLaunchData = Omit<
	typeof launches.$inferInsert,
	"id" | "createdAt" | "updatedAt"
>;

/**
 * Fetches launch records from the database.
 * Optionally filters launches by launchpad name.
 * @param filter Optional string. If provided and not "All", filters by `launches.launchpad`.
 * @returns A promise that resolves to an array of launch objects.
 */
export async function getLaunches(filter?: string) {
	console.log(
		`Fetching launches from DB. Filter: ${filter ?? "None (fetching all)"}`,
	);
	// Uses Drizzle's query builder (`db.query.launches`).
	const result = await db.query.launches.findMany({
		// Conditional 'where' clause:
		// - If a filter exists and is not the string "All", it adds a condition
		//   where the `launchpad` column must equal the filter value (`eq(launches.launchpad, filter)`).
		// - Otherwise (no filter or filter is "All"), the `where` clause is undefined, fetching all records.
		where:
			filter && filter !== "All" ? eq(launches.launchpad, filter) : undefined,
		// Orders the results by the `createdAt` column in descending order (newest first).
		orderBy: (launches, { desc }) => [desc(launches.createdAt)],
	});
	console.log(`Fetched ${result.length} launches.`);
	return result;
}

/**
 * Fetches a distinct list of all launchpad names present in the database.
 * Useful for populating filter dropdowns or lists.
 * @returns A promise that resolves to an array of unique launchpad name strings.
 */
export async function getDistinctLaunchpads() {
	console.log("Fetching distinct launchpads from DB...");
	// Uses Drizzle's `selectDistinct` to get unique values from the `launchpad` column.
	const distinctLaunchpadsResult = await db
		.selectDistinct({ launchpad: launches.launchpad })
		.from(launches); // Specifies the table to query from.

	// The result is an array of objects like [{ launchpad: 'Name1' }, { launchpad: 'Name2' }].
	// We map this to extract just the names into a simple string array.
	const launchpadNames = distinctLaunchpadsResult.map(
		({ launchpad }) => launchpad,
	);
	console.log(`Found ${launchpadNames.length} distinct launchpads.`);
	return launchpadNames;
}

/**
 * Inserts a new launch record into the database.
 * After successful insertion, it triggers a revalidation of the Next.js cache
 * for the homepage ('/') to ensure the UI reflects the new data.
 * @param launchData An object conforming to the NewLaunchData type.
 */
export async function addLaunch(launchData: NewLaunchData) {
	console.log(`Attempting to add new launch to DB: ${launchData.title}`);
	try {
		// Uses Drizzle's `insert` method to add a new row to the 'launches' table.
		// `.values(launchData)` provides the data for the new row.
		await db.insert(launches).values(launchData);
		console.log(
			`Successfully added launch: ${launchData.title} from ${launchData.launchpad}`,
		);

		// Revalidate the cache for the specified path. This tells Next.js to
		// fetch fresh data for this path on the next request, ensuring the homepage
		// list is updated without requiring a manual refresh or redeploy.
		console.log("Revalidating Next.js cache for path: /");
		revalidatePath("/");
		console.log("Cache revalidation triggered for /.");
	} catch (error) {
		// Log any errors that occur during the database insertion process.
		console.error(
			`Error adding launch "${launchData.title}" to database:`,
			error,
		);
		// Depending on application requirements, you might:
		// - Throw the error to be handled by a higher-level error handler.
		// - Implement specific error handling (e.g., for unique constraint violations).
		// - Send the error to an external monitoring service.
		// throw error; // Uncomment to propagate the error
	}
}
